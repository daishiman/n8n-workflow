# n8n ワークフロー構築の本質：重要要素完全ガイド

n8n が大事にしているワークフロー構築の核心要素を体系的に整理しました。実際にワークフローを組む上で必要な知識のみに焦点を当てています。

---

## 1. データ構造の理解：n8n の根幹となる思想

### データはすべて配列で流れる

n8n の最も重要な原則は、すべてのデータが配列形式で流れることです。これを理解していないと、ワークフロー構築で必ず躓きます。

```javascript
// 標準的なn8nデータ構造
[
  {
    json: {
      id: 1,
      name: "田中太郎",
      email: "tanaka@example.com",
    },
  },
  {
    json: {
      id: 2,
      name: "佐藤花子",
      email: "sato@example.com",
    },
  },
];
```

### アイテムとバイナリデータ

- JSON データ: `.json` プロパティに構造化データが格納される
- バイナリデータ: `.binary` プロパティに画像、PDF、ファイルが格納される
- メタデータ: `.pairedItem` で前のノードとの関連性を追跡

### 重要な原則

1. 1 つのノードは複数のアイテムを同時に処理できる
2. 各アイテムは独立して扱われる
3. データ変換時も配列構造は維持される

---

## 2. ノードの 4 つの役割：ワークフローの構成要素

n8n のノードは明確に 4 つの役割に分類され、この理解がワークフロー設計の基礎となります。

### トリガーノード（稲妻アイコン）

ワークフローの開始点。1 つのワークフローに 1 つだけ配置可能。

#### Schedule Trigger - 時間ベース実行

```
使用場面：定期的なレポート作成、データ同期、バックアップ
設定例：
- 毎日午前9時：0 9 * * *
- 2時間ごと：0 */2 * * *
- 平日のみ：0 9 * * 1-5
```

#### Webhook - イベント駆動実行

```
使用場面：外部システムからのリアルタイムトリガー
特徴：
- テストURL（開発用）と本番URL（稼働用）の2種類
- 認証設定が必須（Basic/Header/JWT）
- レスポンスモードの選択が重要
```

#### Polling Trigger - 定期チェック

```
使用場面：新規メール、新規ファイル、データ変更の検知
特徴：
- 定期的にサービスをチェック
- 前回実行以降の変更のみを取得
```

### アクションノード

実際の作業を実行するノード。ワークフローの主要部分。

- HTTP Request: 最も汎用性が高く、任意の API に接続可能
- サービス専用ノード: Google Sheets、Slack、Gmail、Notion など 400+
- データベースノード: PostgreSQL、MySQL、MongoDB などの直接操作

### フローロジックノード

条件分岐、ループ、データ変換を担当。

#### IF Node - 条件分岐

```javascript
条件例：
- {{ $json.amount }} > 10000（金額チェック）
- {{ $json.status }} === "approved"（ステータス確認）
- {{ $json.email }}.includes("@company.com")（ドメインチェック）
```

#### Switch Node - 複数分岐

```
単一の値で複数の経路に分岐
例：注文ステータス（pending/approved/rejected/cancelled）
```

#### Loop Over Items - 繰り返し処理

```
配列の各要素に対して同じ処理を実行
注意：大量データ処理では Split in Batches を使用
```

#### Split in Batches - バッチ処理

```
重要度：★★★★★
1000件のデータを100件ずつ処理するなど、
大規模データを効率的に処理する必須ノード
```

### データ変換ノード

データの形式変更、整形、集計を担当。

- Set Node: フィールドの追加、削除、名前変更
- Code Node: JavaScript/Python でカスタムロジック
- Aggregate: データの集計、グループ化
- Merge: 複数のデータソースの結合

---

## 3. Expression：データアクセスの言語

n8n の Expression（式）は、ワークフロー内でデータを動的に扱うための最重要機能です。

### 基本構文

```javascript
// 二重中括弧で囲む
{
  {
    $json.fieldName;
  }
}

// 現在のアイテムのデータにアクセス
{
  {
    $json.email;
  }
}
{
  {
    $json.user.name;
  }
} // ネストされたデータ

// 特定ノードのデータにアクセス
{
  {
    $("ノード名").item.json.fieldName;
  }
}

// すべてのアイテムにアクセス
{
  {
    $("ノード名").all();
  }
}
```

### 重要なビルトイン変数

```javascript
// 現在のデータ
$json; // 現在のアイテムのJSONデータ
$binary; // バイナリデータ
$input; // 入力データ全体

// メタデータ
$now; // 現在の日時（Luxon DateTime）
$today; // 今日の日付（Luxon DateTime）
$workflow; // ワークフロー情報（ID、名前）
$execution; // 実行情報（ID、モード）

// ノード参照
$("NodeName"); // 特定ノードのデータ
```

### 実践的な Expression 例

```javascript
// 文字列操作
{
  {
    $json.email.toLowerCase();
  }
} // 小文字化
{
  {
    $json.text.trim();
  }
} // 空白除去
{
  {
    $json.html.removeTags();
  }
} // HTMLタグ除去

// 配列操作
{
  {
    $json.tags.unique();
  }
} // 重複除去
{
  {
    $json.items.length;
  }
} // 要素数取得
{
  {
    $json.numbers.sum();
  }
} // 合計

// 日時操作（Luxon統合）
{
  {
    $now.toFormat("yyyy-MM-dd");
  }
} // 日付フォーマット
{
  {
    $now.plus({ days: 7 }).toISO();
  }
} // 7日後
{
  {
    $now.toTimeZone("Asia/Tokyo");
  }
} // タイムゾーン変換

// 条件式
{
  {
    $json.amount > 10000 ? "高額" : "通常";
  }
}

// 複雑な変換
{
  {
    $json.items
      .filter((item) => item.price > 1000)
      .map((item) => item.name)
      .join(", ");
  }
}
```

### Expression 使用時の重要原則

1. 常にデータの存在を確認する: `{{ $json.user?.name || 'Unknown' }}`
2. 型を意識する: 数値計算では `parseInt()` や `parseFloat()` を使用
3. テストモードで検証する: 実行前に必ず Expression の結果を確認

---

## 4. データの流れと変換：ワークフローの血流

### データパイプラインの思想

n8n はデータパイプラインの考え方を採用しています。各ノードはデータを受け取り、変換し、次のノードに渡します。

```
[入力] → [変換1] → [変換2] → [分岐] → [出力A]
                              └─────→ [出力B]
```

### データ変換の 3 つのパターン

#### 1. フィールド操作（Set Node）

```
使用場面：フィールドの追加、削除、名前変更
例：
- APIレスポンスから必要なフィールドだけ抽出
- 計算フィールドの追加
- データ構造の整形
```

#### 2. カスタムロジック（Code Node）

```javascript
// Run Once for All Items（効率的）
const outputItems = [];
for (const item of $input.all()) {
  outputItems.push({
    json: {
      fullName: `${item.json.firstName} ${item.json.lastName}`,
      processedAt: new Date().toISOString(),
    },
  });
}
return outputItems;

// Run Once for Each Item（個別処理）
return {
  json: {
    result: $json.value * 2,
  },
};
```

#### 3. データ集約（Aggregate Node）

```
使用場面：グループ化、集計、統計
例：
- 顧客ごとの注文合計
- 月別の売上集計
- カテゴリ別の平均値
```

### データ結合の戦略

```javascript
// Merge Node の3つのモード

1. Append（追加）
   データ1: [A, B]
   データ2: [C, D]
   結果: [A, B, C, D]

2. Combine（組み合わせ）
   各入力から1つずつ取得して結合

3. Match（一致ベース結合）
   指定フィールドで一致するデータを結合（SQLのJOINに相当）
```

---

## 5. エラーハンドリング：本番運用の必須要素

n8n は 3 層のエラーハンドリングを提供します。これを正しく実装することが、本番運用の成否を分けます。

### レイヤー 1: ノードレベルのエラー設定

各ノードの設定で「On Error」動作を選択：

```
Stop Workflow（デフォルト）
→ エラーで即座に停止

Continue
→ エラーを無視して次へ進む
→ 重要度の低い処理に使用

Continue with Error Output
→ エラー情報を次のノードに渡す
→ エラーログ記録に最適
```

### レイヤー 2: Try-Catch パターン

```
構成：
[処理ノード] → [成功時の処理]
     ↓（エラー時）
[エラー処理ノード]
```

### レイヤー 3: Error Workflow（最重要）

すべての本番ワークフローに必須の機能

```yaml
設定手順：
1. エラー専用ワークフローを作成
2. Error Triggerノードで開始
3. 通知・ログ記録ノードを追加
4. メインワークフローの Settings → Error Workflow で紐付け

エラーデータに含まれる情報：
- ワークフロー名とID
- 実行ID
- エラーが発生したノード名
- エラーメッセージとスタックトレース
- タイムスタンプ
```

### エラーハンドリングのベストプラクティス

```javascript
// リトライロジックの実装
指数バックオフパターン：
試行1: 即座
試行2: 5秒待機
試行3: 15秒待機
試行4: 45秒待機

// エラー通知の優先度分け
Critical: Slack通知 + メール + PagerDuty
Warning: Slackのみ
Info: ログ記録のみ
```

---

## 6. ワークフロー設計パターン：実践的な構成法

### パターン 1: ETL パイプライン

```
[Extract: データ取得]
    ↓
[Transform: データ変換・クレンジング]
    ↓
[Load: データ保存]
```

使用例：

- Google Sheets → 変換 → データベース
- API → フィルタリング → Slack 通知

### パターン 2: イベント駆動処理

```
[Webhook受信]
    ↓
[検証・フィルタリング]
    ↓
[条件分岐] → [処理A]
           → [処理B]
           → [処理C]
```

使用例：

- フォーム送信 → 顧客区分 → 各担当者に通知
- 決済完了 → 金額判定 → 異なる承認フロー

### パターン 3: バッチ処理

```
[Schedule Trigger: 定期実行]
    ↓
[データ取得]
    ↓
[Split in Batches: 100件ずつ]
    ↓
[処理ループ]
    ↓
[結果集約]
    ↓
[レポート送信]
```

使用例：

- 毎日の在庫チェック
- 週次レポート生成
- 月次の請求書作成

### パターン 4: サブワークフロー分割

```
[メインワークフロー]
    ↓
[Execute Workflow: サブワークフローA]
    ↓
[Execute Workflow: サブワークフローB]
    ↓
[結果の集約]
```

原則：

- 1 ワークフロー = 1 つの責務
- 再利用可能なロジックはサブワークフロー化
- 複雑さは分割で管理

---

## 7. n8n が大事にする設計思想

### 思想 1: データファースト

すべてはデータの流れを中心に設計する

- データ構造を先に定義
- 各ノードでのデータ変換を明確に
- 不要なデータは早期に除外

### 思想 2: モジュール性

小さく、再利用可能なワークフローを作る

```
悪い例：
1つの巨大ワークフロー（100+ノード）

良い例：
- メインワークフロー（制御フロー）
- データ取得ワークフロー
- データ処理ワークフロー
- 通知ワークフロー
```

### 思想 3: 明示的エラーハンドリング

エラーは必ず発生する前提で設計

- すべての外部 API 呼び出しにリトライロジック
- Error Workflow の必須実装
- エラーログの一元管理

### 思想 4: テスタビリティ

常にテスト可能な状態を保つ

- Webhook はテストモードで開発
- 手動実行で簡単に検証可能
- 本番データとテストデータの分離

### 思想 5: 可視性

ワークフローの状態が一目で分かる

- 明確なノード名（「HTTP Request」ではなく「顧客データ取得」）
- Sticky Note で説明を追加
- 実行履歴の定期的なレビュー

---

## 8. 実装時の重要チェックリスト

### ワークフロー開始前

- [ ] データ構造を明確に定義した
- [ ] トリガーの種類を正しく選択した
- [ ] エラーハンドリング戦略を決定した
- [ ] ワークフローの責務を 1 つに絞った

### ノード配置時

- [ ] 各ノードに明確な名前を付けた
- [ ] データの流れが論理的に正しい
- [ ] 不要なデータは早期にフィルタリング
- [ ] Expression の構文をテストした

### デバッグ時

- [ ] 各ノードの出力データを確認
- [ ] Expression の結果を検証
- [ ] エラー時の動作を確認
- [ ] 境界値（空データ、大量データ）をテスト

### 本番デプロイ前

- [ ] Error Workflow を設定した
- [ ] タイムゾーン設定を確認した
- [ ] 認証情報が安全に保存されている
- [ ] Webhook に認証を設定した
- [ ] レート制限を考慮した
- [ ] ログとモニタリングを設定した

---

## 9. よくある落とし穴と解決策

### 落とし穴 1: データ構造の誤解

```javascript
❌ 間違い：
{{ $json }}  // これは1つのアイテム

✅ 正解：
{{ $input.all() }}  // すべてのアイテムの配列
```

### 落とし穴 2: 無限ループ

```
原因：Loop Over Itemsの終了条件が不明確

解決策：
1. Split in Batchesを使用
2. 必ず終了条件を設定
3. 最大繰り返し回数を制限
```

### 落とし穴 3: レート制限違反

```javascript
問題：1000件のデータに対して即座に1000回API呼び出し

解決策：
- Split in Batchesで分割（10-50件ずつ）
- 各バッチ間に Wait ノードで遅延追加（1-5秒）
- バッチ並列実行は避ける
```

### 落とし穴 4: タイムゾーンの不一致

```
問題：スケジュール実行が期待した時刻に動かない

解決策：
- ワークフロー設定でタイムゾーンを明示
- $now使用時は .toTimeZone() で変換
- Cronパターンの時刻がワークフローのタイムゾーンで解釈されることを理解
```

### 落とし穴 5: Expression 内の undefined

```javascript
❌ エラーになる：
{{ $json.user.address.city }}  // userがundefinedの場合エラー

✅ 安全な書き方：
{{ $json.user?.address?.city || 'Unknown' }}  // オプショナルチェーン
```

---

## 10. 最重要原則：5 つの金言

### 1. シンプルであること

複雑さは敵。1 ワークフロー = 1 つの明確な目的。

### 2. データ構造を理解すること

n8n のデータは配列。これを忘れると何も始まらない。

### 3. エラーは起こる前提で設計すること

Error Workflow のない本番ワークフローは存在しない。

### 4. テストしてからデプロイすること

手動実行、テストデータ、境界値チェックは必須。

### 5. 監視と改善を続けること

実行履歴を定期的にレビューし、ボトルネックを特定し、継続的に最適化する。

---

## まとめ：ワークフロー構築の本質

n8n でワークフローを組む上で最も重要なのは、データの流れを中心に考える思考です。

1. データ構造を理解する（すべては配列）
2. 適切なノードを選択する（トリガー、アクション、フローロジック、変換）
3. Expression で動的にデータを扱う
4. エラーを想定して設計する（3 層のハンドリング）
5. 小さく保ち、モジュール化する

これらの原則を守れば、保守しやすく、スケーラブルで、信頼性の高いワークフローを構築できます。技術的な複雑さではなく、論理的な明確さと堅牢性こそが、優れたワークフローの条件です。
