# CLAUDE.md

このファイルは、Claude Code (claude.ai/code) がこのリポジトリで作業する際のガイダンスを提供します。

## プロジェクト概要

**n8nワークフロー自動設計システム** - 業務要件から完全なn8nワークフローJSONファイルを生成するAI駆動型フレームワークです。本システムは、12層アーキテクチャと12要素フレームワークを用いた3フェーズ構造のプロセス（Phase 1: 要件定義・設計、Phase 2: JSON生成、Phase 3: 統合・出力）を使用します。

## コアアーキテクチャ

### 12層アーキテクチャフレームワーク

**データフロー層（L1-L7）:**
- L1: Trigger（トリガー） - イベント検知・受信
- L2: Input（入力） - データ受信・初期化
- L3: Validation（検証） - 入力検証・フォーマット確認
- L4: Transformation（変換） - データ変換・加工
- L5: Core Logic（コアロジック） - AI判断・ビジネスロジック（AI Agent Node配置）
- L6: Integration（統合） - 外部連携・API呼び出し
- L7: Output（出力） - 結果出力・通知

**横断的関心事層（L8-L12）:**
- L8: Error Handling（エラー処理） - エラー検知・リカバリ
- L9: Security（セキュリティ） - 認証・認可・暗号化
- L10: Monitoring（監視） - ログ出力・メトリクス収集
- L11: Performance（パフォーマンス） - キャッシュ・並列処理
- L12: Orchestration（オーケストレーション） - フロー制御・条件分岐

### 3フェーズワークフロー生成プロセス

**Phase 1: 要件定義・設計（Step010-060）**
- Step010: 業務理解（12要素フレームワークによるヒアリング）
- Step020: AI設定（最適AIモデル選定）
- Step030: 技術要件変換（12層アーキテクチャへのマッピング）
- Step040: タスク分解とグループ化
- Step050: AIエージェント責務定義
- Step060: パターン適用と詳細設計

**Phase 2: JSON生成（Step070-149）**
- Step070-129: メインフローグループJSON生成（最大30グループ）
- Step130-149: エラーフローグループJSON生成（最大10グループ）
- 各グループは `.claude/agents/step070-メインフローグループJSON生成テンプレート.md` のテンプレートを使用

**Phase 3: 統合・出力（Step150-190）**
- Step150: グループ間接続統合
- Step160: ワークフロー全体検証
- Step170: 配置最適化
- Step180: Sticky Note完成
- Step190: 最終出力（完全なワークフローJSON）

## エージェントプロンプトの使用方法

### 配置場所
すべてのエージェントプロンプトは `.claude/agents/` ディレクトリに配置：
- step010-業務理解.md
- step020-AI設定.md
- step030-技術要件変換.md
- step040-タスク分解とグループ化.md
- step050-AIエージェント責務定義.md
- step060-パターン適用と詳細設計.md
- step070-メインフローグループJSON生成テンプレート.md
- step150-グループ間接続統合.md
- step160-ワークフロー全体検証.md
- step170-配置最適化.md
- step180-StickyNote完成.md
- step190-最終出力.md

### プロンプト構造
各プロンプトは以下の形式に従う：
```markdown
# 目的
# 背景
# 言葉の定義
# 制約
# 処理手順
## 処理手順の全体フロー
## 処理手順1-N
# 初回質問
```

### エージェント命名規則
各ステップは実在する専門家・フレームワークに基づくエージェント名を指定：
- システムアーキテクト（グレディ・ブーチ『オブジェクト指向分析設計』）
- データエンジニア（マーティン・クレップマン『データ指向アプリケーション設計』）
- SREエンジニア
- n8nエキスパート
- データフローエンジニア
- テクニカルライター

## 出力ディレクトリ構造

ワークフロー設計プロセスを実行すると、以下の構造で出力が保存される：
```
./{業務目的}/
├── step010_業務理解/
│   └── 業務理解書.md
├── step020_AI設定/
│   └── AI設定書.md
├── step030_技術要件変換/
│   └── 技術要件書.md
├── step040_タスク分解/
│   └── グループ構成表.md
├── step050_AIエージェント責務/
│   └── AIエージェント責務定義書.md
├── step060_パターン適用/
│   └── 詳細設計書.md
├── step070_Group1_JSON/
│   └── Group1_[グループ名].json
├── ...
├── step150_統合JSON/
│   └── 統合ワークフロー.json
└── step190_最終成果物/
    ├── README.md
    ├── {業務目的}_workflow_integrated_v4.json
    ├── {業務目的}_metadata_v4.json
    ├── 実装手順書.md
    └── 検証レポート.md
```

## n8n-MCP統合

### 必須MCPツール
- `search_nodes({query, category})` - n8nノードを検索
- `get_node_essentials({nodeType, includeExamples})` - ノード詳細を取得
- `get_node_documentation({nodeType})` - 読みやすいドキュメントを取得
- `validate_node_operation({nodeType, config})` - ノード設定を検証
- `validate_workflow({workflow})` - ワークフロー全体を検証

### ノードタイプ形式
常にプレフィックス付きの完全なノードタイプを使用：
- コアノード: `n8n-nodes-base.webhook`, `n8n-nodes-base.httpRequest`
- AIノード: `@n8n/n8n-nodes-langchain.agent`

## 実行フロー

### 新規ワークフロー設計の開始

1. Step010から順番にプロンプトを実行
2. 各ステップは `./{業務目的}/step{番号}_{ステップ名}/` に出力
3. 各ステップ完了後、次に進む前にユーザーの承認を得る
4. n8n-MCPを使用してノードタイプと設定を検証
5. 設計全体を通して12層アーキテクチャを適用

### テンプレート使用方法（Phase 2）

グループNのJSON生成：
1. `step070-メインフローグループJSON生成テンプレート.md` をコピー
2. `[N]` を実際のグループ番号（1, 2, 3, ...）に置換
3. `[グループ名]` をStep060のグループ名に置換
4. Step060の詳細設計からグループNの情報を抽出
5. プロンプトを実行してJSONを生成

### トークン最適化

- 各グループJSONは2500トークン以下を推奨
- グループサイズ: 3-15ノードを推奨
- 超過した場合: グループサイズを縮小またはパラメータを簡素化

## Sticky Note設計ポリシー

すべてのSticky Noteは以下のルールに従う：

**パターン1（全体フロー）:**
- 最小サイズ: 760×650
- 色: 7（薄ピンク） - 固定
- `### 🔗 関連ノードブロック` セクションを含み、すべてのノードの役割と接続を記載

**パターン2（各グループ）:**
- 最小サイズ: 540×420
- 色: メインフロー（2/3/4/6）、エラーフロー（5）
- 白色系（0/1）は絶対に使用禁止
- グループフローと関連ノードブロックを含める
- 層、依存関係、主要データをMarkdownで視覚的に表示

## Gitワークフロー

`.github/GIT_WORKFLOW.md` に従ってブランチ戦略とコミット規約を遵守：
- ブランチ命名: `feature/[機能名]-[YYYYMMDD]`
- コミット形式: `[種別]: [変更内容]`
  - 種別: feat, fix, docs, style, refactor, test, chore
- 常にフィーチャーブランチで作業、mainでは作業しない
- 変更をプッシュ後にPRを作成
- マージ済みブランチは定期的にクリーンアップ

## 共通制約

### 出力制約（全ステップ共通）
- 各ステップ完了後にユーザー確認を要求
- 承認後のみ次ステップに進む
- 指定されたディレクトリに出力を保存

### 検証要件
- ノード選定と検証にn8n-MCPを使用
- すべてのノードは正しいtypeVersionを持つ
- すべての必須パラメータが定義されていることを確認
- ノード間の接続互換性をチェック

### 設計原則
- AIエージェントに単一責任の原則を適用
- 12層への完全なマッピングが必須
- データフローを明示的にする（入力 → 処理 → 出力）
- 横断的関心事を適切な層に統合

## 実行例

`./Google_Meet議事録自動化_v4.0/` に完全な実行例あり：
- Step010からStep190までのすべてのステップ出力を含む
- グループJSON（Step070-092）を含む
- 最終統合ワークフロー: `step190_最終成果物/Google_Meet議事録自動化システム_workflow_integrated_v4.json`
- 検証と変換のためのヘルパースクリプトが `scripts/` に配置

## 重要な注意事項

- これは**設計フレームワーク**であり、実行可能コードではない
- 出力はn8nにインポートするためのn8nワークフローJSON
- AI CLI（Claude Code）がプロンプトを実行、自動化スクリプトではない
- 各業務要件はプロジェクトルート直下に新しいディレクトリを作成
- プロセスは反復的 - フィードバックに基づいてステップを修正可能
