# 目的

Phase 2で生成した全グループ（メイン+エラー）のJSONを1つのワークフローJSONに統合し、グループ間接続を追加して、完全に接続されたワークフローを作成する。

# 背景

各グループは独立してJSON生成されているが、グループ間の接続は未定義。このステップで、Group 1 → Group 2 → ... の接続と、メインフロー → エラーフローの接続を追加し、ワークフロー全体を完成させる。

# 言葉の定義

- **グループ間接続**: 前グループの最終ノード → 次グループの開始ノードの接続
- **エラーフロー接続**: メインフローノード → Error Trigger → エラーグループの接続
- **統合JSON**: 全グループを1つにまとめたワークフローJSON
- **孤立ノード**: 入力も出力もないノード（Sticky Note以外は禁止）
- **接続整合性**: すべての接続先ノードIDがnodesに存在すること

# 制約

- 出力制約: 統合JSONを出力後、ユーザーに確認を求め、承認後にStep160へ進む
- 完全接続必須: 孤立ノード（Sticky Note以外）が0個であること
- エラーフロー統合必須: エラーフローを別ファイルではなく同一JSONに含めること
- ワークフロー名必須: Step010の業務目的に基づく名前を設定すること
- 出力ディレクトリ: `./{業務目的}/step150_統合JSON/` に成果物を格納すること

# 処理手順

## 処理手順の全体フロー

```
開始（Step070-149の全グループJSON）
  ↓
1. 全グループJSONの収集
  ↓
2. nodesセクションの統合
  ↓
3. connectionsセクションの統合
  ↓
4. グループ間接続の追加
  ↓
5. エラーフロー接続の追加
  ↓
6. 統合JSONの検証
  ↓
7. 統合JSONの出力
  ↓
完了（Step160へ）
```

## 処理手順1: 全グループJSONの収集

- 目的: Phase 2で生成したすべてのグループJSONを収集する
- 背景: 統合の準備
- エージェント名: データコレクター
- 役割: すべてのグループJSONを収集・整理する
- 責務: グループJSONリストの作成
- 処理詳細手順:
  1. メインフローグループJSONをすべて収集（Group 1-N）
  2. エラーフローグループJSONをすべて収集（Error Group 1-M）
  3. 収集状況を確認
- 評価・判断基準:
  - すべてのグループJSONが収集されていること
- 出力テンプレート:
```markdown
### 収集グループJSON

**メインフローグループ**: [N]個
- Group 1: データ受信・初期化
- Group 2: 入力検証・前処理
- Group 3: AI判断・要約生成
- Group 4: 外部API連携・出力

**エラーフローグループ**: [M]個
- Error Group 1: 入力エラー
- Error Group 2: AI処理エラー
- Error Group 3: API連携エラー

**総グループ数**: [N+M]個
```

## 処理手順2: nodesセクションの統合

- 目的: すべてのグループのnodesを1つの配列にまとめる
- 背景: 統合ワークフローのnodesセクションを構築する
- エージェント名: ノード統合エンジニア
- 役割: nodes配列を統合する
- 責務: 統合nodes配列の作成
- 処理詳細手順:
  1. 各グループJSONのnodesセクションを抽出
  2. 1つの配列にマージ:
     ```json
     {
       "nodes": [
         // Group 1のノード
         ...
         // Group 2のノード
         ...
         // Error Group 1のノード
         ...
       ]
     }
     ```
  3. ノードIDの重複がないか確認
  4. 総ノード数を確認
- 評価・判断基準:
  - すべてのグループのノードが含まれていること
  - ノードIDが一意であること
  - 総ノード数が10-50の範囲内であること
- 出力テンプレート:
```markdown
### 統合nodesセクション

**総ノード数**: [X]個
- メインフローノード: [Y]個
- エラーフローノード: [Z]個
- Sticky Noteノード: [W]個

**ノードID一意性チェック**: ✅ 重複なし
```

## 処理手順3: connectionsセクションの統合

- 目的: すべてのグループのconnectionsを1つのオブジェクトにまとめる
- 背景: 統合ワークフローのconnectionsセクションを構築する
- エージェント名: 接続統合エンジニア
- 役割: connectionsオブジェクトを統合する
- 責務: 統合connectionsオブジェクトの作成
- 処理詳細手順:
  1. 各グループJSONのconnectionsセクションを抽出
  2. 1つのオブジェクトにマージ:
     ```json
     {
       "connections": {
         // Group 1の接続
         "webhook_1": {...},
         "set_1": {...},
         // Group 2の接続
         ...
         // Error Group 1の接続
         ...
       }
     }
     ```
  3. 接続整合性を確認（接続先ノードIDがすべて存在するか）
- 評価・判断基準:
  - すべてのグループの接続が含まれていること
  - 接続先ノードIDがすべてnodesに存在すること
- 出力テンプレート:
```markdown
### 統合connectionsセクション

**総接続数**: [X]個
- メインフロー内部接続: [Y]個
- エラーフロー内部接続: [Z]個

**接続整合性チェック**: ✅ すべての接続先ノードIDが存在
```

## 処理手順4: グループ間接続の追加

- 目的: メインフローグループ間の接続を追加する
- 背景: Group 1 → Group 2 → Group 3 → ... の接続を確立する
- エージェント名: グループ間接続エンジニア
- 役割: グループをつなぐ接続を追加する
- 責務: グループ間接続の追加
- 処理詳細手順:
  1. Step040のグループ構成表を確認
  2. 各グループの最終ノードと次グループの開始ノードを特定:
     - Group 1の最終ノード: `code_1`
     - Group 2の開始ノード: `if_validation_1`
     - 接続: `code_1` → `if_validation_1`
  3. connectionsオブジェクトに追加:
     ```json
     "code_1": {
       "main": [
         [{"node": "if_validation_1", "type": "main", "index": 0}]
       ]
     }
     ```
  4. すべてのグループ間接続を追加
- 評価・判断基準:
  - すべてのグループがつながっていること
  - メインフローが Trigger → Output まで完結していること
- 出力テンプレート:
```markdown
### グループ間接続

| 接続元 | 接続先 | 接続内容 |
|-------|-------|---------|
| Group 1: code_1 | Group 2: if_validation_1 | データ受信 → 検証 |
| Group 2: transform_1 | Group 3: ai_agent_1 | 前処理 → AI処理 |
| Group 3: set_result_1 | Group 4: slack_1 | AI結果 → Slack投稿 |
| Group 4: respond_1 | - | 完了レスポンス（終端） |
```

## 処理手順5: エラーフロー接続の追加

- 目的: メインフロー → エラーフローの接続を追加する
- 背景: エラー発生時にエラーグループへルーティングする接続を確立する
- エージェント名: エラーフロー接続エンジニア
- 役割: エラーハンドリング接続を追加する
- 責務: エラーフロー接続の追加
- 処理詳細手順:
  1. Step040のエラーフローグループ構成表を確認
  2. 各エラーグループのトリガー元を特定:
     - Error Group 1のトリガー元: Group 1-2のノード
     - Error Group 2のトリガー元: Group 3のノード
  3. メインフローノードにエラー接続を追加:
     ```json
     "ai_agent_1": {
       "main": [
         [{"node": "set_result_1", "type": "main", "index": 0}]
       ],
       "error": [
         [{"node": "error_trigger_2", "type": "main", "index": 0}]
       ]
     }
     ```
  4. エラーグループから通常フローへの復帰接続も追加（リカバリー成功時）
- 評価・判断基準:
  - すべてのメインフローノードにエラー接続があること
  - エラーグループがすべて接続されていること
- 出力テンプレート:
```markdown
### エラーフロー接続

| メインフローノード | エラー接続先 | エラー種類 |
|----------------|------------|----------|
| if_1 (Group 1) | error_trigger_1 | 入力エラー |
| ai_agent_1 (Group 3) | error_trigger_2 | AI処理エラー |
| slack_1 (Group 4) | error_trigger_3 | API連携エラー |

**リカバリー接続**:
- Error Group 2成功時 → Group 4 (slack_1)
- Error Group 3成功時 → 終了
```

## 処理手順6: 統合JSONの検証

- 目的: 統合ワークフローJSONの完全性を検証する
- 背景: 接続漏れ・孤立ノードを検出するため
- エージェント名: ワークフロー検証エンジニア
- 役割: 統合JSONを多角的に検証する
- 責務: 検証レポートの作成
- 処理詳細手順:
  1. **構造検証**:
     - nodesがnullでない
     - connectionsがnullでない
     - トリガーノードが1つ以上存在
     - 出力ノード（Respond to Webhook等）が存在
  2. **接続検証**:
     - 孤立ノード（Sticky Note以外）が0個
     - 循環参照がない
     - すべての接続先ノードIDが存在
  3. **フロー検証**:
     - Trigger → Output のパスが存在
     - エラーフローがすべて接続されている
  4. n8n-MCPで検証:
     ```
     validate_workflow({workflow: {...}})
     ```
- 評価・判断基準:
  - すべての検証項目が合格すること
  - n8n-MCP検証が合格すること
- 出力テンプレート:
```markdown
### 統合JSON検証結果

**構造検証**:
- ✅ nodes: 24ノード存在
- ✅ connections: 20接続存在
- ✅ トリガーノード: webhook_1 (1個)
- ✅ 出力ノード: respond_1 (1個)

**接続検証**:
- ✅ 孤立ノード: 0個（Sticky Note除く）
- ✅ 循環参照: なし
- ✅ 接続先ノードID: すべて存在

**フロー検証**:
- ✅ Trigger → Output パス: 存在
- ✅ エラーフロー接続: すべて完了

**n8n-MCP検証**:
- ✅ validate_workflow: 合格
- ⚠️ 警告: なし
- ❌ エラー: なし
```

## 処理手順7: 統合JSONの出力

- 目的: 検証済みの統合ワークフローJSONを最終出力する
- 背景: n8nにインポート可能な完全なワークフローの完成
- エージェント名: 成果物出力マネージャー
- 役割: 最終JSONを整形して出力する
- 責務: 統合ワークフローJSONファイルの作成
- 処理詳細手順:
  1. 統合JSONに以下のメタデータを追加:
     ```json
     {
       "name": "[Step010の業務目的に基づくワークフロー名]",
       "nodes": [...],
       "connections": {...},
       "settings": {
         "executionOrder": "v1"
       },
       "staticData": null,
       "tags": ["v4", "auto-generated", "[業務カテゴリ]"],
       "triggerCount": 0,
       "updatedAt": "2025-11-10T00:00:00.000Z",
       "versionId": "v4.0"
     }
     ```
  2. JSON全体を整形（インデント2スペース）
  3. ファイル名: `[業務目的]_workflow_integrated_v4.json`
  4. ユーザー確認用の要約を作成
- 評価・判断基準:
  - ワークフロー名が設定されていること
  - メタデータがすべて設定されていること
- 出力テンプレート:
```json
{
  "name": "Google Meet議事録自動要約ワークフロー",
  "nodes": [
    // 統合されたすべてのノード
  ],
  "connections": {
    // 統合されたすべての接続 + グループ間接続 + エラーフロー接続
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": ["v4", "auto-generated", "meeting-minutes"],
  "triggerCount": 0,
  "updatedAt": "2025-11-10T00:00:00.000Z",
  "versionId": "v4.0"
}
```

**統合完了サマリー**:
```markdown
# 統合ワークフローJSON完成

**ワークフロー名**: [業務目的に基づく名前]
**総ノード数**: [X]個
**総接続数**: [Y]個
**グループ数**: メイン[N] + エラー[M] = [N+M]個

**検証結果**: ✅ すべて合格
**n8nインポート可能**: ✅ 可能

**次ステップ**: ワークフロー全体検証（Step160）
```

# 初回質問

「Phase 2の全グループJSON生成が完了しました。これからグループ間接続統合を行います。

**収集グループ数**:
- メインフローグループ: [N]個
- エラーフローグループ: [M]個
- 総ノード数: [X]個

統合を開始してよろしいですか？

（選択肢）
1. このまま統合する
2. グループリストを確認してから統合する
3. 個別グループJSONを再確認する」
