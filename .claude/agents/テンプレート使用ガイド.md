# n8n ワークフローテンプレート - 完全版 使用ガイド

## 概要

`ワークフローテンプレート - 完全版.json` は、すべてのn8n実行パターンをサポートする包括的なテンプレートです。

## サポートされる実行パターン

### 1. Sequential (順次実行)
**用途**: A → B → C の線形処理
```
Trigger → Process A → Process B → Process C → Response
```

**ユースケース**:
- ステップバイステップのデータ変換
- 依存関係のあるAPI呼び出しチェーン
- 状態を保持するパイプライン処理

**テンプレート参照**: `execution_patterns.sequential`

---

### 2. Parallel (並列実行)
**用途**: Split → [A, B, C] → Merge の同時実行
```
Trigger → [API Call A, API Call B, API Call C] → Merge → Next
```

**ユースケース**:
- 複数サービスへの並列API呼び出し
- 独立したデータエンリッチメント
- Fan-out/Fan-in処理

**重要ノード**:
- `n8n-nodes-base.merge` (結果の統合)

**Mergeモード**:
- `append`: すべての入力アイテムを結合
- `combine`: 位置でマッチング
- `keepMatches`: 一致するアイテムのみ
- `enrichInput1`: input1をinput2で強化

**テンプレート参照**: `execution_patterns.parallel`

---

### 3. Loop (ループ処理)
**用途**: Split in Batches → Process → Loop back
```
Trigger → Split in Batches → Process Batch → (loop back) → Merge
```

**ユースケース**:
- 大量データのバッチ処理
- レート制限のあるAPI呼び出し
- 反復データ変換

**重要パラメータ**:
```json
{
  "batchSize": 10,
  "options": {
    "reset": false
  }
}
```

**テンプレート参照**: `execution_patterns.loop`

---

### 4. Conditional (条件分岐)
**用途**: IF → [True Branch, False Branch] → Merge
```
Trigger → IF Node → [Success Handler, Error Handler] → Merge
```

**ユースケース**:
- 成功/失敗パスのある検証
- ビジネスロジックルーティング
- フォールバック付きエラーハンドリング

**IFノード構造**:
```json
{
  "conditions": {
    "options": {"version": 2},
    "combinator": "and|or",
    "conditions": [
      {
        "leftValue": "={{ $json.status }}",
        "rightValue": "active",
        "operator": {
          "type": "string",
          "operation": "equals"
        }
      }
    ]
  }
}
```

**重要**: IFノードは2つの出力を持つ
- `main[0]`: True branch (条件が満たされた場合)
- `main[1]`: False branch (条件が満たされない場合)

**テンプレート参照**: `execution_patterns.conditional`

---

### 5. AI Agent Cluster (AIエージェント構造)
**用途**: AI Agent + Subnodes の完全構造
```
Trigger → AI Agent (+ Chat Model + Memory + Output Parser) → Validation
```

**必須サブノード**:
1. **Chat Model** (`ai_languageModel` 接続)
2. **Memory** (`ai_memory` 接続)

**オプションサブノード**:
3. **Output Parser** (`ai_outputParser` 接続) - 構造化出力用
4. **Tools** (`ai_tool` 接続) - 外部ツール統合用

**ユースケース**:
- 自然言語処理
- 構造化データ抽出
- 会話型ワークフロー
- AI駆動の意思決定

**AI Agentパラメータ**:
```json
{
  "promptType": "define",
  "text": "={{ $json.userMessage }}",
  "hasOutputParser": true,
  "options": {
    "systemMessage": "You are a helpful assistant...",
    "maxIterations": 3
  }
}
```

**Temperature推奨値**:
- `0.1-0.3`: 精度重視（データ抽出、分類）
- `0.7-0.9`: 創造性重視（コンテンツ生成、ブレインストーミング）

**重要**: AI出力は必ずCodeノードで検証する

**テンプレート参照**: `execution_patterns.ai_agent_cluster`

---

### 6. Mixed Dependencies (複合パターン)
**用途**: 複数パターンの組み合わせ
```
Webhook → Extract → AI Analysis → IF → [Parallel APIs] → Merge → Loop → Response
```

**ユースケース**:
- エンタープライズワークフロー
- 多段階データ処理パイプライン
- 状態管理付き会話型ワークフロー

**設計原則**:
- 関連ノードを論理グループに整理
- Sticky Noteで各セクションを文書化
- 左から右へ明確なデータフローを維持
- Mergeノードで並列ブランチを統合
- 重要な移行ポイントでデータ検証

**テンプレート参照**: `execution_patterns.mixed_dependencies`

---

## グループベース構造

### グループ設計

**推奨グループ数**: 5-7グループ

**典型的なグループタイプ**:
1. Input Reception Group (入力受信)
2. Data Validation Group (データ検証)
3. AI Processing Group (AI処理)
4. External API Integration Group (外部API統合)
5. Conditional Routing Group (条件分岐)
6. Data Transformation Group (データ変換)
7. Output/Response Group (出力/応答)
8. Error Handling Group (エラーハンドリング)

### Sticky Note テンプレート

```json
{
  "parameters": {
    "content": "📌 Group: データ検証グループ\n\nNodes:\n- Input Validation\n- Field Extraction\n- Type Checking\n\nPurpose: Webhookペイロードから必須フィールドを抽出し検証\n\nExecution Pattern: Sequential\n\nData Flow: Webhook payload → Validated data object",
    "height": 350,
    "width": 500,
    "color": 2
  },
  "type": "n8n-nodes-base.stickyNote"
}
```

**色分け推奨**:
- 色1 (赤): エラーハンドリング
- 色2 (青): データ処理
- 色3 (緑): 成功フロー
- 色4 (黄): 条件分岐
- 色5 (紫): AI処理
- 色6 (オレンジ): 外部API
- 色7 (グレー): ドキュメンテーション

---

## 使用手順

### Step 1: 要件分析
```
✓ 必要な実行パターンを特定
✓ データフローを設計
✓ 必要なノードタイプを決定
✓ エラーハンドリング戦略を定義
```

### Step 2: パターン選択
```
テンプレートから適切なパターンを選択:
- Sequential: 線形処理が必要な場合
- Parallel: 並列実行で高速化する場合
- Loop: バッチ処理が必要な場合
- Conditional: 条件分岐が必要な場合
- AI Agent: AI処理が必要な場合
- Mixed: 複数パターンの組み合わせ
```

### Step 3: カスタマイズ
```javascript
// 1. プレースホルダーを実際の値に置換
{{WORKFLOW_NAME}} → "顧客データ処理ワークフロー"
{{NODE_NAME}} → "Validate Customer Data"
{{GROUP_NAME}} → "Data Validation Group"

// 2. UUID生成
{{NODE_UUID}} → crypto.randomUUID()
// 例: "a1b2c3d4-e5f6-7890-abcd-ef1234567890"

// 3. パラメータ設定
// ⚠️ すべてのパラメータを明示的に設定（デフォルトに依存しない）
{
  "parameters": {
    "httpMethod": "POST",  // 明示的に設定
    "path": "customer-webhook",
    "responseMode": "lastNode"
  }
}
```

### Step 4: 接続作成
```json
{
  "connections": {
    "Webhook Trigger": {
      "main": [[{"node": "Extract Data", "type": "main", "index": 0}]]
    },
    "Extract Data": {
      "main": [[{"node": "Validate Data", "type": "main", "index": 0}]]
    }
  }
}
```

**IFノードの場合**:
```json
{
  "IF Node": {
    "main": [
      [{"node": "True Handler", "type": "main", "index": 0}],  // main[0] = true
      [{"node": "False Handler", "type": "main", "index": 0}]  // main[1] = false
    ]
  }
}
```

**AI Agentの場合**:
```json
{
  "Chat Model": {
    "ai_languageModel": [[{"node": "AI Agent", "type": "ai_languageModel", "index": 0}]]
  },
  "Memory": {
    "ai_memory": [[{"node": "AI Agent", "type": "ai_memory", "index": 0}]]
  },
  "Output Parser": {
    "ai_outputParser": [[{"node": "AI Agent", "type": "ai_outputParser", "index": 0}]]
  }
}
```

### Step 5: 検証
```bash
# n8n-MCP検証ツールを使用

# 1. ノード最小検証
validate_node_minimal(nodeType, config)

# 2. ノード完全検証
validate_node_operation(nodeType, config, 'runtime')

# 3. ワークフロー検証
validate_workflow(workflow)

# 4. 接続検証
validate_workflow_connections(workflow)

# 5. 式検証
validate_workflow_expressions(workflow)
```

---

## 検証チェックリスト

### 作成前チェック
- [ ] すべてのノードタイプをn8n-MCPで確認
- [ ] すべてのパラメータを `validate_node_minimal` で検証
- [ ] AI Agentサブノード構造を確認
- [ ] 実行パターンを要件にマッピング

### 作成後チェック
- [ ] すべてのノードに一意のUUID ID
- [ ] すべての接続が既存ノード名を参照
- [ ] AI Agentが `ai_languageModel` + `ai_memory` 接続を持つ
- [ ] 孤立ノードがない（意図的な場合を除く）
- [ ] 意図しない循環参照がない（ループパターン以外）
- [ ] すべてのパラメータが明示的に設定
- [ ] IFノードブランチが適切にラベル付け (main[0]=true, main[1]=false)
- [ ] Mergeノードが正しい入力接続を持つ
- [ ] ループパターンが適切に構造化
- [ ] Sticky Noteが適切に配置・色分け

---

## パターン組み合わせ例

### 例1: 条件分岐 + 並列実行 + AI Agent
```
Webhook
  → Extract Data
  → IF (Check Category)
      → [True: Category A]
          → AI Agent (Analyze A)
          → [API Call 1, API Call 2, API Call 3] (Parallel)
          → Merge
      → [False: Category B]
          → AI Agent (Analyze B)
          → API Call 4
  → Merge Results
  → Send Response
```

### 例2: ループ + AI Agent + 条件分岐
```
Webhook
  → Split in Batches (batchSize: 10)
  → AI Agent (Process Item)
  → IF (Quality Check)
      → [True: Save to DB]
      → [False: Flag for Review]
  → Merge Batches
  → Send Summary
```

### 例3: 複数AIエージェント + 状態管理
```
Webhook
  → Load State (Code)
  → IF (Has Previous State?)
      → [False: New Flow]
          → AI Agent 1 (Initial Analysis)
          → Save State
          → Present Options
      → [True: Continuation Flow]
          → Load Saved State
          → AI Agent 2 (Process Selection)
          → Clear State
          → Execute Action
  → Send Response
```

---

## 一般的なノード設定（完全抽象化版）

### 汎用ノードテンプレート

すべての具体値を `{{変数名}}` 形式で抽象化し、どのようなノードタイプでも対応可能な構造にしています。

```json
{
  "id": "{{NODE_UUID}}",
  "name": "{{NODE_NAME}}",
  "type": "{{NODE_TYPE}}",
  "typeVersion": {{NODE_TYPE_VERSION}},
  "position": [{{POSITION_X}}, {{POSITION_Y}}],
  "parameters": {{NODE_PARAMETERS}},
  "credentials": {{NODE_CREDENTIALS}},
  "_comment": "{{NODE_COMMENT}}",
  "notes": "{{NODE_NOTES}}"
}
```

### Webhook (トリガー)
```json
{
  "type": "n8n-nodes-base.webhook",
  "parameters": {
    "httpMethod": "{{HTTP_METHOD}}",
    "path": "{{WEBHOOK_PATH}}",
    "responseMode": "{{RESPONSE_MODE}}",
    "options": {{WEBHOOK_OPTIONS}}
  }
}
```

### Set (データ変換)
```json
{
  "type": "n8n-nodes-base.set",
  "parameters": {
    "mode": "{{manual|runOnceForAllItems|runOnceForEachItem}}",
    "assignments": {
      "assignments": [
        {
          "id": "{{ASSIGNMENT_UUID}}",
          "name": "{{OUTPUT_FIELD_NAME}}",
          "value": "={{{{EXPRESSION}}}}",
          "type": "{{string|number|boolean|array|object}}"
        }
      ]
    }
  }
}
```

### Code (カスタムロジック)
```json
{
  "type": "n8n-nodes-base.code",
  "parameters": {
    "mode": "{{runOnceForAllItems|runOnceForEachItem}}",
    "language": "{{javaScript|python}}",
    "jsCode": "{{JAVASCRIPT_CODE}}",
    "pythonCode": "{{PYTHON_CODE}}"
  }
}
```

### HTTP Request (API呼び出し)
```json
{
  "type": "n8n-nodes-base.httpRequest",
  "parameters": {
    "method": "{{GET|POST|PUT|DELETE|PATCH}}",
    "url": "{{API_URL}}",
    "authentication": "{{AUTHENTICATION_TYPE}}",
    "nodeCredentialType": "{{CREDENTIAL_TYPE}}",
    "sendHeaders": {{SEND_HEADERS_BOOLEAN}},
    "headerParameters": {
      "parameters": [
        {
          "name": "{{HEADER_NAME}}",
          "value": "{{HEADER_VALUE}}"
        }
      ]
    },
    "sendQuery": {{SEND_QUERY_BOOLEAN}},
    "queryParameters": {
      "parameters": [
        {
          "name": "{{QUERY_PARAM_NAME}}",
          "value": "{{QUERY_PARAM_VALUE}}"
        }
      ]
    },
    "sendBody": {{SEND_BODY_BOOLEAN}},
    "contentType": "{{CONTENT_TYPE}}",
    "bodyParameters": {{BODY_PARAMETERS}},
    "options": {
      "timeout": {{TIMEOUT_MS}},
      "redirect": {
        "redirect": {
          "follow": {{FOLLOW_REDIRECTS_BOOLEAN}},
          "maxRedirects": {{MAX_REDIRECTS}}
        }
      }
    }
  }
}
```

### IF (条件分岐)
```json
{
  "type": "n8n-nodes-base.if",
  "parameters": {
    "conditions": {
      "options": {"version": 2},
      "combinator": "{{and|or}}",
      "conditions": [
        {
          "id": "{{CONDITION_UUID}}",
          "leftValue": "={{{{LEFT_VALUE_EXPRESSION}}}}",
          "rightValue": "{{RIGHT_VALUE}}",
          "operator": {
            "type": "{{string|number|boolean|dateTime}}",
            "operation": "{{OPERATION_TYPE}}"
          }
        }
      ]
    }
  }
}
```

**Operator Types**:
- **string**: equals, notEquals, contains, notContains, startsWith, endsWith, regex, notEmpty
- **number**: equals, notEquals, larger, largerEqual, smaller, smallerEqual
- **boolean**: true, false, equals, notEquals
- **dateTime**: equals, notEquals, after, before

### Merge (データ統合)
```json
{
  "type": "n8n-nodes-base.merge",
  "parameters": {
    "mode": "{{append|combine|combineBySql|chooseBranch}}",
    "combineBy": "{{combineByPosition|combineByFields}}",
    "joinMode": "{{keepMatches|keepNonMatches|keepEverything|enrichInput1|enrichInput2}}",
    "outputDataFrom": "{{both|input1|input2}}",
    "options": {{MERGE_OPTIONS}}
  }
}
```

### Split in Batches (バッチ処理)
```json
{
  "type": "n8n-nodes-base.splitInBatches",
  "parameters": {
    "batchSize": {{BATCH_SIZE}},
    "options": {
      "reset": {{RESET_BOOLEAN}}
    }
  }
}
```

### AI Agent（完全抽象化）
```json
{
  "type": "@n8n/n8n-nodes-langchain.agent",
  "parameters": {
    "promptType": "{{auto|define}}",
    "text": "={{{{PROMPT_EXPRESSION}}}}",
    "hasOutputParser": {{HAS_OUTPUT_PARSER_BOOLEAN}},
    "options": {
      "systemMessage": "{{SYSTEM_MESSAGE}}",
      "maxIterations": {{MAX_ITERATIONS}}
    }
  }
}
```

### Chat Model (AI Agentサブノード)
```json
{
  "type": "{{@n8n/n8n-nodes-langchain.lmChatOpenAi|@n8n/n8n-nodes-langchain.lmChatAnthropic|@n8n/n8n-nodes-langchain.lmChatGoogleGemini}}",
  "parameters": {
    "model": "{{MODEL_NAME}}",
    "options": {
      "temperature": {{TEMPERATURE}},
      "maxTokens": {{MAX_TOKENS}},
      "topP": {{TOP_P}},
      "topK": {{TOP_K}}
    }
  },
  "credentials": {
    "{{CREDENTIAL_TYPE}}": {
      "id": "{{CREDENTIAL_ID}}",
      "name": "{{CREDENTIAL_NAME}}"
    }
  }
}
```

### Memory (AI Agentサブノード)
```json
{
  "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
  "parameters": {
    "sessionIdType": "{{fromInput|customKey}}",
    "sessionKey": "={{{{SESSION_KEY_EXPRESSION}}}}",
    "contextWindowLength": {{CONTEXT_WINDOW_LENGTH}}
  }
}
```

### Output Parser (AI Agentサブノード)
```json
{
  "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
  "parameters": {
    "schemaType": "{{fromJson|manual}}",
    "jsonSchemaExample": "{{JSON_SCHEMA_EXAMPLE}}",
    "inputSchema": "{{JSON_SCHEMA}}",
    "options": {
      "autoFix": {{AUTO_FIX_BOOLEAN}}
    }
  }
}
```

### 汎用データ処理ノード
```json
{
  "type": "{{n8n-nodes-base.XXXXX}}",
  "parameters": {
    "resource": "{{RESOURCE_TYPE}}",
    "operation": "{{OPERATION_TYPE}}",
    "{{PARAMETER_1}}": "={{{{EXPRESSION_1}}}}",
    "{{PARAMETER_2}}": "={{{{EXPRESSION_2}}}}",
    "options": {{NODE_OPTIONS}}
  },
  "credentials": {
    "{{CREDENTIAL_TYPE}}": {
      "id": "{{CREDENTIAL_ID}}",
      "name": "{{CREDENTIAL_NAME}}"
    }
  }
}
```

---

## n8n式パターン（完全抽象化版）

### データアクセス
```javascript
$json.{{FIELD_NAME}}                                      // 現在アイテムのフィールド
$json.{{NESTED}}.{{FIELD}}                                // ネストされたフィールド
$input.first().json.{{FIELD_NAME}}                        // 最初のアイテムを明示的に
$input.all()                                              // すべてのアイテム (Codeノード内)
$node['{{NODE_NAME}}'].json.{{FIELD_NAME}}                // 特定ノードからデータ
$items('{{NODE_NAME}}')[{{INDEX}}].json.{{FIELD_NAME}}    // 特定ノードのアイテム
$env.{{ENVIRONMENT_VARIABLE}}                             // 環境変数
$now.{{DATE_METHOD}}()                                    // 現在日時
$credentials.{{CREDENTIAL_FIELD}}                         // 認証情報
```

### 一般的な操作
```javascript
={{ $json.{{FIELD_1}} + $json.{{FIELD_2}} }}                             // 加算
={{ $json.{{TEXT_FIELD}}.{{STRING_METHOD}}() }}                          // 文字列操作
={{ $json.{{DATE_FIELD}}.{{DATE_METHOD}}() }}                            // 日付操作
={{ $json.{{ARRAY_FIELD}}.length }}                                      // 配列長
={{ $json.{{CONDITION}} ? '{{TRUE_VALUE}}' : '{{FALSE_VALUE}}' }}        // 三項演算子
={{ JSON.stringify($json.{{OBJECT_FIELD}}) }}                            // JSON文字列化
={{ $json.{{NUMBER_FIELD}} {{OPERATOR}} {{VALUE}} }}                     // 計算
={{ $json.{{STRING_FIELD}}.trim() }}                                     // トリム
={{ $json.{{ARRAY}}.map({{ITEM}} => {{ITEM}}.{{FIELD}}) }}               // 配列マップ
={{ $json.{{ARRAY}}.filter({{ITEM}} => {{ITEM}}.{{CONDITION}}) }}        // 配列フィルター
={{ $json.{{ARRAY}}.reduce(({{ACC}}, {{ITEM}}) => {{LOGIC}}, {{INIT}}) }} // 配列リデュース
={{ $json.{{OBJECT}}.{{KEY}} || {{DEFAULT_VALUE}} }}                     // デフォルト値
```

### 検証パターン
```javascript
={{ $json.{{FIELD}} || '{{DEFAULT_VALUE}}' }}                                              // デフォルト値
={{ $json.{{FIELD}} && $json.{{FIELD}}.trim() !== '' }}                                   // 非空チェック
={{ /{{REGEX_PATTERN}}/.test($json.{{FIELD}}) }}                                          // 正規表現検証
={{ [{{VALUE_LIST}}].includes($json.{{FIELD}}) }}                                         // リスト内チェック
={{ typeof $json.{{FIELD}} === '{{TYPE}}' && $json.{{FIELD}} {{OPERATOR}} {{VALUE}} }}   // 型+条件検証
={{ $json.{{DATE_FIELD}} && new Date($json.{{DATE_FIELD}}) {{OPERATOR}} new Date() }}    // 日付検証
```

### 複雑な変換パターン
```javascript
// オブジェクトのマージ
={{ Object.assign({}, $json.{{OBJECT_1}}, $json.{{OBJECT_2}}) }}

// 配列のフラット化
={{ $json.{{NESTED_ARRAY}}.flat({{DEPTH}}) }}

// 条件付きフィールド追加
={{ { ...$json, {{NEW_FIELD}}: {{CONDITION}} ? {{VALUE_1}} : {{VALUE_2}} } }}

// 複数ノードからのデータ統合
={{ {
  {{FIELD_1}}: $node['{{NODE_1}}'].json.{{SOURCE_FIELD_1}},
  {{FIELD_2}}: $node['{{NODE_2}}'].json.{{SOURCE_FIELD_2}},
  {{FIELD_3}}: $json.{{CURRENT_FIELD}}
} }}
```

---

## ベストプラクティス

### ノード整理
1. Sticky Noteで各グループを文書化
2. 実行フローに従って左から右へノードを配置
3. 一貫した垂直間隔を維持 (推奨: 100px)
4. 関連ノードを視覚的にグループ化
5. グループごとに異なるSticky Note色を使用

### パラメータ設定
1. **常にすべてのパラメータを明示的に設定** - デフォルトに依存しない
2. 動的な値にはn8n式を使用
3. すべてのユーザー入力を検証
4. null/undefined値を適切に処理
5. 複雑なロジックにはCodeノードを使用

### AI Agent使用
1. 常にChat ModelとMemoryサブノードを含める
2. 構造化データ抽出にはOutput Parserを使用
3. 精度重視: temperature 0.1-0.3、創造性重視: 0.7-0.9
4. AI出力をCodeノードで検証
5. 制御されたワークフローでは maxIterations を3-5に制限

### エラーハンドリング
1. 重要な操作の後に検証IFノードを追加
2. グローバルエラーキャッチにError Triggerノードを使用
3. ユーザーフレンドリーなエラーメッセージを提供
4. デバッグ用にエラーをログ記録
5. API失敗時のフォールバックロジックを実装

### パフォーマンス
1. 可能な限り並列実行を使用
2. レート制限を尊重するためAPIコールをバッチ化
3. 大規模データセットにはSplit in Batchesを使用
4. Codeノード使用を最小化 (ネイティブノードを優先)
5. 頻繁にアクセスされるデータをキャッシュ

---

## トラブルシューティング

### よくある問題

#### 1. "Node not found" エラー
**原因**: 接続が存在しないノード名を参照
**解決**: すべての接続がnode名と完全一致することを確認

#### 2. AI Agent実行失敗
**原因**: サブノード接続の欠落
**解決**: `ai_languageModel` と `ai_memory` 接続を確認

#### 3. IFノードが常に同じブランチ
**原因**: 条件設定が不適切
**解決**:
```json
{
  "conditions": {
    "options": {"version": 2},  // 必須
    "conditions": [/* ... */]
  }
}
```

#### 4. Mergeノードがデータを失う
**原因**: Mergeモード設定が不適切
**解決**:
- `append`: すべてのデータを保持
- `combine`: 位置でマッチング
- `keepEverything`: すべてを保持 + マッチステータス

#### 5. Split in Batchesが無限ループ
**原因**: ループバック接続の誤り
**解決**: Processノードは両方に接続する必要がある:
1. Split in Batches (ループバック用)
2. Merge (最終出力用)

#### 6. パラメータデフォルト値エラー
**原因**: デフォルト値に依存
**解決**: すべてのパラメータを明示的に設定

---

## リファレンス

### テンプレートセクション
- `meta`: テンプレートメタデータ
- `execution_patterns`: 6つの実行パターン
- `group_based_structure`: グループ設計ガイドライン
- `complete_workflow_template`: ベースワークフロー構造
- `validation_checklist`: 検証ステップ
- `common_node_configurations`: ノード設定例
- `expression_patterns`: n8n式パターン
- `best_practices`: ベストプラクティス

### 外部リソース
- n8n公式ドキュメント: https://docs.n8n.io
- n8n Community: https://community.n8n.io
- n8n Workflows: https://n8n.io/workflows (2,709+ テンプレート)

---

**作成日**: 2025-01-09
**バージョン**: 1.0.0
**メンテナンス**: n8nワークフロー自動設計エージェント
