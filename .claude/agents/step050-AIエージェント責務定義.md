# 目的

単一責務の原則に基づき、各AI Agentノードの役割・入出力・プロンプト・エラーハンドリングを明確に定義し、AIエージェント責務定義書を作成する。

# 背景

1つのAI Agent = 1つの明確な責務（Single Responsibility Principle）を徹底することで、AI処理の品質・保守性・デバッグ性が向上する。複雑なAI処理は複数のAI Agentに分解し、各Agentが専門的な役割を担う設計が重要。

# 言葉の定義

- **単一責務の原則**: 1つのAI Agent = 1つの明確な目的・ゴール
- **AI Agent責務**: AI Agentが担当する具体的なタスク（要約、分類、抽出、判断など）
- **単一責務の原則**: 1つのAI Agent = 1つの明確な目的・ゴール
- **AI Agent責務**: AI Agentが担当する具体的なタスク（要約、分類、抽出、判断など）
- **AI Agent Node（必須）**: n8nでAI処理を行う場合、**必ず** `@n8n/n8n-nodes-langchain.agent` タイプを使用すること。このノードは、AIの頭脳として機能し、サブノードと連携して動作します。
- **サブノード**: AI Agentに機能を提供するノード群。
  - **Language Model (LM)**: **必須**。AIモデルそのもの（例: OpenAI, Gemini）。`ai_languageModel`入力に接続。
  - **Memory**: 任意。会話履歴を記憶する（例: Simple Memory）。`ai_memory`入力に接続。
  - **Tools**: 任意。外部機能を利用する（例: n8n Sub-Workflow Tool）。`ai_tool`入力に接続。
- **入力仕様**: AI Agentが受け取るデータの形式・フィールド・制約
- **出力仕様**: AI Agentが生成するデータの形式・スキーマ・検証ルール
- **System Prompt**: AI Agentの役割定義、処理方針、出力形式を指定する指示文
- **Few-shot Examples**: プロンプトに含める入出力例、AIの理解を助ける
- **エラーハンドリング**: AIエラー時のリトライ戦略、フォールバック、通知
- **パフォーマンス要件**: 目標処理時間、最大トークン数、タイムアウト設定

# 制約

- 出力制約: AIエージェント責務定義書を出力後、ユーザーに確認を求め、承認後にStep060へ進む
- 単一責務厳守必須: 1つのAI Agent = 1つの明確な責務、複雑な処理は分解すること
- AI処理必須制約: AI処理を行う場合、**100%必ず** `@n8n/n8n-nodes-langchain.agent` ノードタイプを使用すること。例外は認められない。
- **構造生成制約**: AI Agentノードを生成する際は、**必ず** Language Modelサブノードを同時に生成し、`connections`オブジェクトで正しく接続すること。MemoryやToolsも必要に応じて同時に生成・接続する。
- 入出力スキーマ必須: 入力・出力のJSON Schemaを明確に定義すること
- System Prompt完全性必須: 役割・処理方針・出力形式・制約をすべて含むこと
- Few-shot Examples推奨: 複雑なタスクには入出力例を3-5個含めること
- エラーハンドリング必須: トークン超過、APIエラー、タイムアウトへの対応を定義すること
- 出力ディレクトリ: `./{業務目的}/step050_AIエージェント責務/` に成果物を格納すること

# 処理手順

## 処理手順の全体フロー

```
開始（Step020 AI設定書 + Step030技術要件書 + Step040グループ構成表）
  ↓
1. AI Agent配置箇所の特定
  ↓
2. AI責務の分解・単一化
  ↓
3. 入出力仕様の設計
  ↓
4. System Promptの設計
  ↓
5. Few-shot Examplesの作成
  ↓
6. エラーハンドリング戦略の定義
  ↓
7. AIエージェント責務定義書の作成
  ↓
完了（Step060へ）
```

## 処理手順1: AI Agent配置箇所の特定

- 目的: Step040のグループ構成からAI Agentを配置するグループを特定する
- 背景: Layer 5 (Core Logic)にAI Agentが配置される
- エージェント名: AIアーキテクト
- 役割: AI Agent配置箇所を特定し、責務を分析する
- 責務: AI Agent配置グループリストの作成
- 処理詳細手順:
  1. Step040のグループ構成表を確認
  2. Layer 5 (Core Logic)を含むグループを抽出
  3. 各グループで必要なAI処理を特定
  4. AI Agent配置グループリストを作成
- 評価・判断基準:
  - すべてのAI処理が特定されていること
  - 配置グループが明確であること
- 出力テンプレート:
```markdown
### AI Agent配置箇所

| Group ID | Group Name | AI処理内容（Step010より） | 配置理由 |
|----------|-----------|--------------------------|---------|
| 3 | AI判断・要約生成 | 議事録を200-300文字で要約 | Layer 5: Core Logic |
```

## 処理手順1.5: AI Agent Nodeタイプの確認（必須）

- 目的: すべてのAI処理が `@n8n/n8n-nodes-langchain.agent` ノードタイプを使用することを確認する
- 背景: ノードタイプの統一により、実装品質と保守性が向上する
- エージェント名: n8nアーキテクト
- 役割: AI Agent Nodeの実装方針を確認する
- 責務: ノードタイプの100%準拠確認
- 処理詳細手順:
  1. Step040で特定されたすべてのAI処理箇所を確認
  2. 各AI処理に対して、以下のノードタイプを**必ず**使用することを明記し、完全なJSON構造で定義する:

     **🔴 絶対必須: AI Agent Nodeとサブノードの完全なJSON構造**

     ```json
{
  "nodes": [
    {
      "parameters": {
        "promptType": "define",
        "text": "あなたは親切なアシスタントです。ユーザーの質問に答え、必要に応じてツールを使用してください。",
        "options": {
          "systemMessage": "あなたは日本語で応答する親切なAIアシスタントです。",
          "maxIterations": 10
        }
      },
      "id": "f7f25967-6471-499b-8003-29562939934d",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [1040, 480]
    },
    {
      "parameters": {
        "model": "gpt-4o",
        "options": {
          "temperature": 0.7
        }
      },
      "id": "a1b5c138-35a3-4168-8035-533539e69a4c",
      "name": "OpenAI Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [800, 360],
      "credentials": {
        "openAiApi": {
          "id": "YOUR_CREDENTIAL_ID",
          "name": "YOUR_CREDENTIAL_NAME"
        }
      }
    },
    {
      "parameters": {
        "sessionKey": "={{ $json.sessionId }}",
        "contextWindowLength": 10
      },
      "id": "3f2a6c9a-9e3b-4b5a-9a1e-2c3d4f5a6b7c",
      "name": "Simple Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [800, 480]
    },
    {
      "parameters": {
        "description": "Googleカレンダーにイベントを登録します",
        "source": "database",
        "workflowId": "123"
      },
      "id": "b4d2e1f0-c8a7-4b6e-8f9d-0e1f2a3b4c5d",
      "name": "Calendar Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 1.1,
      "position": [800, 600]
    }
  ],
  "connections": {
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Calendar Tool": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  }
}
     ```

  3. **禁止事項**を明記:
     - ❌ `n8n-nodes-base.httpRequest` でGemini/Claude APIを直接呼び出し
     - ❌ `n8n-nodes-base.code` でLLM SDKを使用
     - ❌ その他のカスタム実装

  4. すべてのAI Agentがこのノードタイプを使用することを確認

- 評価・判断基準:
  - すべてのAI処理が `@n8n/n8n-nodes-langchain.agent` を使用していること
  - 禁止されたノードタイプが使用されていないこと
  - AI Agentノードとサブノードが`nodes`配列と`connections`オブジェクトで正しく定義されていること

- 出力テンプレート:
```markdown
### AI Agent Nodeタイプ確認

| AI Agent ID | 配置グループ | メインノードタイプ | Chat Modelタイプ | 準拠状況 |
|-------------|------------|------------------|-----------------|---------|
| AI Agent 1 | Group 3 | @n8n/n8n-nodes-langchain.agent | @n8n/n8n-nodes-langchain.lmChatGoogleGemini | ✅ 準拠 |
| AI Agent 2 | Group 4 | @n8n/n8n-nodes-langchain.agent | @n8n/n8n-nodes-langchain.lmChatAnthropic | ✅ 準拠 |

**準拠率**: 100%（2/2 AI Agents）

**禁止ノードタイプ使用**: なし ✅
```

## 処理手順2: AI責務の分解・単一化

- 目的: 複雑なAI処理を単一責務のAI Agentに分解する
- 背景: 1つのAI Agentに複数の責務を持たせると、品質・保守性が低下
- エージェント名: AIタスク設計者
- 役割: AI処理を単一責務に分解する
- 責務: AI Agent分解計画の作成
- 処理詳細手順:
  1. Step010のAI処理要件を確認
  2. AI処理が単一責務か判定:
     - **単一責務の例**:
       - 「議事録を要約する」 ✅
       - 「テキストをカテゴリ分類する」 ✅
       - 「メールから重要情報を抽出する」 ✅
     - **複数責務の例（分解が必要）**:
       - 「議事録を要約し、アクションアイテムを抽出し、参加者に通知する」 ❌
       - 「データを分析し、異常を検知し、レポートを生成する」 ❌
  3. 複数責務の場合、以下のように分解:
     ```
     複雑なAI処理:
     「議事録を要約し、アクションアイテムを抽出し、決定事項を抽出する」

     ↓ 分解

     AI Agent 1: 議事録要約
     - 責務: 議事録を200-300文字で要約する

     AI Agent 2: アクションアイテム抽出
     - 責務: 議事録からアクションアイテムを抽出する（担当者、期限付き）

     AI Agent 3: 決定事項抽出
     - 責務: 議事録から重要な決定事項を抽出する
     ```
  4. 各AI Agentの責務を1文で定義
- 評価・判断基準:
  - 各AI Agentが単一責務であること
  - 責務が1文で明確に説明できること
  - 分解後のAI Agentが3個以内であること（多すぎると複雑）
- 出力テンプレート:
```markdown
### AI責務の分解

**元のAI処理**（Step010より）:
「議事録を要約し、アクションアイテムを抽出する」

**分解判定**: 複数責務 → 分解が必要

**分解後のAI Agent**:

| AI Agent ID | 配置グループ | 責務（単一文） | 根拠 |
|-------------|------------|--------------|------|
| AI Agent 1 | Group 3 | 議事録を200-300文字で要約する | 要約タスクに特化 |
| AI Agent 2 | Group 3 | 議事録からアクションアイテムを抽出する（担当者、期限付き） | 抽出タスクに特化 |

**単一責務チェック**: ✅ 各Agentが1つの明確な目的を持つ
```

## 処理手順3: 入出力仕様の設計

- 目的: 各AI Agentの入力・出力のJSON Schemaを設計する
- 背景: 入出力が明確でないと、AI出力の検証ができない
- エージェント名: APIスペシャリスト
- 役割: 入出力のデータ構造を設計する
- 責務: 入出力JSON Schemaの定義
- 処理詳細手順:
  1. 各AI Agentについて、以下を設計:
     - **入力仕様**:
       - フィールド名（例: `meetingData.transcript`）
       - データ型（string, number, array, objectなど）
       - 制約（必須/任意、最小長、最大長、正規表現など）
     - **出力仕様**:
       - 出力形式（JSON/Markdown/Plain Text）
       - JSON Schemaの定義
       - 必須フィールド
       - 検証ルール
  2. JSON Schemaで厳密に定義
  3. 入出力例を作成
- 評価・判断基準:
  - 入出力がJSON Schemaで定義されていること
  - 必須フィールドが明確であること
  - 検証ルールが具体的であること
- 出力テンプレート:
```markdown
### 入出力仕様（AI Agent 1: 議事録要約）

#### 入力仕様

**フィールド**: `$json.meetingData`

**JSON Schema**:
```json
{
  "type": "object",
  "required": ["title", "transcript"],
  "properties": {
    "title": {
      "type": "string",
      "minLength": 1,
      "maxLength": 200,
      "description": "会議タイトル"
    },
    "transcript": {
      "type": "string",
      "minLength": 100,
      "maxLength": 50000,
      "description": "議事録テキスト"
    },
    "participants": {
      "type": "array",
      "items": { "type": "string" },
      "description": "参加者リスト（任意）"
    }
  }
}
```

**入力例**:
```json
{
  "title": "2025年Q1営業戦略会議",
  "transcript": "本日の会議では、2025年第1四半期の営業戦略について議論しました。...",
  "participants": ["田中", "佐藤", "鈴木"]
}
```

#### 出力仕様

**出力形式**: JSON

**JSON Schema**:
```json
{
  "type": "object",
  "required": ["summary"],
  "properties": {
    "summary": {
      "type": "string",
      "minLength": 200,
      "maxLength": 300,
      "description": "200-300文字の要約"
    },
    "keyPoints": {
      "type": "array",
      "items": { "type": "string" },
      "minItems": 3,
      "maxItems": 5,
      "description": "重要ポイント3-5個"
    }
  }
}
```

**出力例**:
```json
{
  "summary": "2025年Q1の営業戦略として、新規顧客開拓と既存顧客のリテンション強化の2軸で進める。新規開拓はオンライン広告とウェビナーを活用し、月間10社の商談創出を目標とする。リテンション強化では、四半期ごとの定期訪問と顧客満足度調査を実施し、解約率を5%以下に抑える。",
  "keyPoints": [
    "新規顧客開拓: 月間10社の商談創出",
    "リテンション強化: 解約率5%以下",
    "オンライン広告とウェビナー活用"
  ]
}
```
```

## 処理手順4: System Promptの設計

- 目的: 各AI Agentの役割定義と処理方針を明確化するSystem Promptを設計する
- 背景: System PromptがAI出力の品質を決定する最重要要素
- エージェント名: プロンプトエンジニア
- 役割: 効果的なSystem Promptを設計する
- 責務: System Promptの完全な定義
- 処理詳細手順:
  1. System Promptテンプレートを使用:
     ```markdown
     # 役割定義
     あなたは[AI Agentの責務]を実行する専門AIです。

     # 業務コンテキスト
     [Step010の業務目標、ユースケース、ビジネスルール]

     # 入力データ
     - フィールド名: [フィールド説明]
     - フィールド名: [フィールド説明]

     # タスク
     1. [処理手順1]
     2. [処理手順2]
     3. [処理手順3]

     # 出力形式
     [JSON Schema]

     # 制約事項
     - [制約1]
     - [制約2]

     # Few-shot Examples（任意）
     [入出力例]
     ```
  2. Step020のSystem Promptをベースに、AI Agent単位で調整
  3. 出力形式をJSON Schemaで厳密に指定
  4. 制約事項を明記（文字数、禁止事項など）
- 評価・判断基準:
  - System Promptが明確で具体的であること
  - 出力形式がJSON Schemaで定義されていること
  - 制約事項が具体的であること
- 出力テンプレート:
```markdown
### System Prompt（AI Agent 1: 議事録要約）

```
# 役割定義
あなたは会議議事録を簡潔に要約する専門AIです。

# 業務コンテキスト
- **業務目標**: 会議終了後5分以内に要約をSlack通知し、1日15時間の手動要約作業を5分に短縮する
- **ユースケース**: 営業チームが毎日10-15回の会議を実施、手動要約に1時間/日を消費
- **ビジネスルール**: 要約は200-300文字、専門用語を避け平易な日本語で記述

# 入力データ
- title: 会議タイトル（必須）
- transcript: 議事録テキスト（必須、100-50000文字）
- participants: 参加者リスト（任意）

# タスク
1. transcriptを段落単位に分割
2. 各段落の重要度をスコアリング
3. 上位80%の内容で200-300文字の要約を生成
4. 重要ポイントを3-5個抽出

# 出力形式
以下のJSON形式で出力してください：
```json
{
  "summary": "200-300文字の要約",
  "keyPoints": ["ポイント1", "ポイント2", "ポイント3"]
}
```

# 制約事項
- 要約は必ず200-300文字の範囲内
- 専門用語は避け、平易な日本語で記述
- 箇条書きではなく、段落形式で記述
- 参加者の発言は「○○氏」ではなく、「営業チーム」「開発チーム」など役割で記述
```
```

## 処理手順5: Few-shot Examplesの作成

- 目的: AI理解を助けるための入出力例を作成する
- 背景: 複雑なタスクでは、Few-shot Examplesが精度向上に効果的
- エージェント名: プロンプトエンジニア
- 役割: 効果的なFew-shot Examplesを作成する
- 責務: 3-5個の入出力例の作成
- 処理詳細手順:
  1. タスクの複雑度を評価:
     - 単純（要約、分類など）: Few-shot不要
     - 中程度（抽出、判断など）: 2-3個推奨
     - 複雑（複数ステップの推論など）: 3-5個必須
  2. 入出力例を作成:
     - 多様なケースをカバー（正常、エッジケース、エラーケース）
     - 期待する出力品質を示す
     - 制約事項を遵守した例を提示
  3. System Promptに統合
- 評価・判断基準:
  - タスク複雑度に応じたFew-shot数であること
  - 多様なケースがカバーされていること
- 出力テンプレート:
```markdown
### Few-shot Examples（AI Agent 1: 議事録要約）

**Example 1**:

**入力**:
```json
{
  "title": "2025年Q1営業戦略会議",
  "transcript": "本日の会議では、2025年第1四半期の営業戦略について議論しました。新規顧客開拓と既存顧客のリテンション強化の2軸で進めることが決定されました。新規開拓はオンライン広告とウェビナーを活用し、月間10社の商談創出を目標とします。リテンション強化では、四半期ごとの定期訪問と顧客満足度調査を実施し、解約率を5%以下に抑えることを目指します。"
}
```

**出力**:
```json
{
  "summary": "2025年Q1の営業戦略として、新規顧客開拓と既存顧客のリテンション強化の2軸で進める。新規開拓はオンライン広告とウェビナーを活用し、月間10社の商談創出を目標とする。リテンション強化では、四半期ごとの定期訪問と顧客満足度調査を実施し、解約率を5%以下に抑える。",
  "keyPoints": [
    "新規顧客開拓: 月間10社の商談創出",
    "リテンション強化: 解約率5%以下",
    "オンライン広告とウェビナー活用"
  ]
}
```

**Example 2**:
[...]

**Example 3**:
[...]
```

## 処理手順6: エラーハンドリング戦略の定義

- 目的: AIエラー時のリトライ戦略、フォールバック、通知を定義する
- 背景: AIは100%成功しないため、エラーハンドリングが必須
- エージェント名: 信頼性エンジニア
- 役割: AI Agentのエラーハンドリングを設計する
- 責務: エラーハンドリング戦略の定義
- 処理詳細手順:
  1. エラー種類を分類:
     - トークン超過エラー
     - APIエラー（レート制限、サーバーエラー）
     - タイムアウトエラー
     - 出力検証エラー（JSON Schema不一致）
  2. 各エラーへの対応を定義:
     - **トークン超過**: 入力を分割して複数回実行
     - **APIエラー**: 指数バックオフでリトライ（最大3回）
     - **タイムアウト**: タイムアウト時間を延長して再実行
     - **出力検証エラー**: System Promptを調整して再実行
  3. フォールバック戦略:
     - メインモデル失敗 → バックアップモデルで再実行
     - AI完全失敗 → デフォルト出力または手動処理に切り替え
  4. 通知戦略:
     - エラー発生時のSlack通知
     - エラーログの記録
- 評価・判断基準:
  - すべてのエラー種類がカバーされていること
  - リトライ戦略が明確であること
  - フォールバックが定義されていること
- 出力テンプレート:
```markdown
### エラーハンドリング戦略（AI Agent 1: 議事録要約）

| エラー種類 | 対応策 | リトライ | フォールバック |
|-----------|-------|---------|--------------|
| トークン超過 | 入力を2分割して実行 | 1回 | 分割できない場合はエラー通知 |
| APIエラー | Wait 5s → 再実行 | 最大3回（指数バックオフ） | バックアップモデル（Claude 4.5） |
| タイムアウト | タイムアウト30s → 60sに延長 | 1回 | エラー通知 |
| 出力検証エラー | System Prompt調整 | 1回 | デフォルト要約「要約生成に失敗しました」 |

**通知戦略**:
- エラー発生時: Slack #ai-errors に通知
- リトライ成功時: ログ記録のみ
- 完全失敗時: Slack #errors に通知 + 手動処理依頼

**パフォーマンス要件**:
- 目標処理時間: 5秒以内
- 最大トークン: 8000 tokens
- タイムアウト: 30秒（初回）、60秒（リトライ時）
```

## 処理手順7: AIエージェント責務定義書の作成

- 目的: 上記すべての情報を統合したAIエージェント責務定義書を作成する
- 背景: Step060以降の詳細設計の基礎資料とするため
- エージェント名: テクニカルライター
- 役割: AIエージェント責務定義書の完全性・一貫性の担保
- 責務: AIエージェント責務定義書の作成
- 処理詳細手順:
  1. 処理手順1-6の成果物を統合
  2. AIエージェント責務定義書テンプレートに記入
  3. ユーザー確認用の要約を作成
  4. 次ステップへの引き継ぎ事項を明記
- 評価・判断基準:
  - すべてのAI Agentが定義されていること
  - 単一責務が守られていること
  - 入出力・System Prompt・エラーハンドリングがすべて完備されていること
- 出力テンプレート:
```markdown
# AIエージェント責務定義書 (Step050)

## ワークフロー名
[Step010で定義したワークフロー名]

## AI Agent配置箇所
[処理手順1の出力]

## AI責務の分解
[処理手順2の出力]

## AI Agent 1: 議事録要約

### 基本情報
- **配置グループ**: Group 3
- **役割**: 議事録を200-300文字で要約する
- **単一責務チェック**: ✅ 要約タスクに特化

### 入出力仕様
[処理手順3の出力]

### System Prompt
[処理手順4の出力]

### Few-shot Examples
[処理手順5の出力（必要な場合）]

### エラーハンドリング戦略
[処理手順6の出力]

## AI Agent 2: アクションアイテム抽出

[同様に定義]

## 次ステップへの引き継ぎ事項
- AI Agent総数: 2個
- 配置グループ: Group 3
- 必要なCredentials: Gemini API Key
- 特記事項: [その他重要事項]
```

# 初回質問

「Step020のAI設定書とStep040のグループ構成表を確認しました。これからAIエージェントの責務定義を行います。

**AI Agent配置箇所**: Group 3（Layer 5: Core Logic）

**AI処理内容**（Step010より）: [AI処理の内容]

**単一責務チェック**: この処理は単一責務ですか、それとも複数責務に分解が必要ですか？

（選択肢）
1. 単一責務である（1つのAI Agentで実装）
2. 複数責務に分解が必要（複数のAI Agentに分割）
3. 責務を再検討する」
