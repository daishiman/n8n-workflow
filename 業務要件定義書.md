## 🎯 業務要件

### 1. トリガー条件

#### Google Drive Trigger 設定
- **方式**: Polling（定期チェック）
- **チェック間隔**: 5分ごと
- **監視フォルダ**: `https://drive.google.com/drive/u/0/folders/1Ddh7AFQooIcogKZeLNnWPqzrq2DX97QH`
- **検知対象**: 新規 M4A ファイルのみ
- **既存ファイル**: 初回実行時は無視（新規ファイルのみ処理）

#### ファイル検知ロジック
- 拡張子が `.m4a` のファイルを検知
- 前回チェック以降に追加されたファイルのみを対象
- ファイル名に `[処理済]` や `processed` が含まれる場合は除外

---

### 2. 処理フロー

#### 全体の流れ

```
[Google Drive Trigger: M4A検知]
         ↓
[Google Drive: ファイル情報取得（URL取得）]
         ↓
[HTTP Request: Deepgram API で文字起こし]
  - ファイルサイズ無制限（数GB対応）
  - Enhanced Japanese Model（日本語特化）
  - Speaker Diarization（話者分離）
         ↓
[Code Node: 文字起こしテキストを行ごとに分割]
         ↓
[Split in Batches: 行ごとにループ処理開始]
         ↓
[AI Agent (Gemini Flash): Step1 - 文字起こし整形]
  - フィラー除去（「えー」「あのー」等）
  - 1行ごとに箇条書き化
  - JSON形式で出力
         ↓
[Merge: ループ終了、全行を統合]
         ↓
[AI Agent (Gemini Flash): Step2 - 議題抽出]
  - 整形済みテキストから議題を抽出
  - JSON形式で出力（議題ごとにオブジェクト）
         ↓
[AI Agent (Gemini Flash): Step3 - 議題分析]
  - 各議題ごとに決定事項、宿題、保留事項を抽出
  - Step2のJSONに追記
         ↓
[AI Agent (Claude Sonnet 4.5): Step4 - フォーマット変換]
  - 全ステップの情報を統合
  - 指定フォーマットで議事録Markdownを生成
         ↓
[AI Agent (Claude Sonnet 4.5): Step5 - 品質保証]
  - 生成された議事録の完全性を検証
  - 不足項目があれば補完提案
         ↓
[Google Drive: 議事録をMarkdownファイルで保存]
  - 保存先: `議事録_出力/` フォルダ
  - ファイル名: `minutes - {YYYY-MM-DD} - {会議名}.md`
         ↓
[Google Drive: 元のM4Aファイルを移動]
  - 移動先: `processed/` サブフォルダ
         ↓
[完了通知（オプション）]
```

---

### 3. データフロー詳細

#### Input（入力）
- **ファイル形式**: M4A（音声ファイル）
- **ファイルサイズ**: 無制限（数GB対応、Deepgram API）
- **保存場所**: Google Drive指定フォルダ
- **ファイルID**: Google Driveから自動取得

#### Processing（処理）

##### Step0: 文字起こし
- **入力**: M4A音声ファイル（数GB対応）
- **処理**: Deepgram API で日本語文字起こし
  - Enhanced Japanese Model使用
  - Speaker Diarization（話者分離）
  - ファイルサイズ無制限
- **出力**: 生テキスト（句読点付き、話者情報付き）

##### Step1: 文字起こし整形
- **入力**: 生テキスト（行分割済み）
- **処理**:
  - フィラー除去（「えー」「あのー」「その」等）
  - 1行ずつ箇条書き化
  - 意味のある文章単位に整形
- **出力**: JSON配列
  ```json
  [
    { "line": 1, "content": "プロジェクトの進捗について報告します" },
    { "line": 2, "content": "現在の完成度は80%です" }
  ]
  ```

##### Step2: 議題抽出
- **入力**: Step1の整形済みJSON
- **処理**:
  - 会話の流れから議題を自動抽出
  - 議題ごとにグループ化
- **出力**: JSON配列
  ```json
  [
    {
      "id": 1,
      "title": "プロジェクト進捗報告",
      "lines": [1, 2, 3, 4]
    },
    {
      "id": 2,
      "title": "次回までのタスク確認",
      "lines": [5, 6, 7]
    }
  ]
  ```

##### Step3: 議題分析
- **入力**: Step2の議題JSON
- **処理**:
  - 各議題ごとに決定事項を抽出
  - 宿題（TODO）を抽出
  - 保留事項を抽出
- **出力**: JSON配列（拡張版）
  ```json
  [
    {
      "id": 1,
      "title": "プロジェクト進捗報告",
      "lines": [1, 2, 3, 4],
      "decisions": ["リリース日を2月1日に確定"],
      "todos": ["開発チームがテストを完了させる"],
      "pending": []
    }
  ]
  ```

##### Step4: フォーマット変換
- **入力**: Step1-3の全JSON + 元のファイルメタデータ
- **処理**:
  - 指定フォーマットに従ってMarkdown生成
  - 日付、会議名、議題、決定事項等を適切に配置
- **出力**: Markdownテキスト

##### Step5: 品質保証
- **入力**: Step4のMarkdown + Step1-3の全データ
- **処理**:
  - 議事録の完全性を検証
  - 必須項目（日時、議題、決定事項等）が揃っているか確認
  - 不足があれば補完または警告
- **出力**: 最終Markdown（検証済み）

#### Output（出力）
- **ファイル形式**: Markdown (`.md`)
- **ファイル名**: `minutes - {YYYY-MM-DD} - {会議名}.md`
  - 例: `minutes - 2025-01-08 - プロジェクト定例会議.md`
- **保存場所**: `議事録_出力/` フォルダ（元のフォルダと同階層）
- **文字コード**: UTF-8

---

### 4. 議事録フォーマット仕様

#### 指定フォーマット（固定）

```markdown
# 目的・背景

{AIが抽出した会議の目的}

# 日時

{YYYY} 年 {MM} 月 {DD} 日（{曜日}） {HH}:{mm} 〜 {HH}:{mm}

# 参加者

{AIが抽出した参加者}、万壽本

# 宿題事項

- {宿題1}
- {宿題2}
- ...

# 決定事項

- {決定事項1}
- {決定事項2}
- ...

# 次回の日時

{YYYY} 年 {MM} 月 {DD} 日（{曜日}） {HH}:{mm} 〜 {HH}:{mm}

# 議事内容

## 本日の議題

- [ ] 議題1：{議題タイトル1}
- [ ] 議題2：{議題タイトル2}
- [ ] 議題3：{議題タイトル3}
...
- [ ] 議題N：{議題タイトルN}

## 議題1：{議題タイトル1}

- {箇条書き内容1}
- {箇条書き内容2}
- ...

## 議題2：{議題タイトル2}

- {箇条書き内容1}
- {箇条書き内容2}
- ...

## 議題3：{議題タイトル3}

- {箇条書き内容1}
- {箇条書き内容2}
- ...

## 議題N：{議題タイトルN}

- {箇条書き内容1}
- {箇条書き内容2}
- ...
```

#### フォーマット要件

1. **目的・背景**: AIが会話から推測して生成
2. **日時**: 元のM4Aファイルの作成日時を使用、終了時刻は音声の長さから計算
3. **参加者**: AIが音声から話者を推定、「万壽本」は常に含める
4. **宿題事項**: Step3で抽出したTODOをリスト化
5. **決定事項**: Step3で抽出した決定事項をリスト化
6. **次回の日時**: AIが会話から次回日程を抽出、言及がなければ「未定」
7. **本日の議題**: Step2で抽出した議題をチェックボックス付きリスト化
8. **議題N**: 各議題の詳細内容を箇条書きで記載

---

### 5. ファイル管理ルール

#### 処理前
- **保存場所**: `/指定フォルダ/会議録.m4a`

#### 処理後
- **M4Aファイル**: `/指定フォルダ/processed/会議録.m4a` に移動
- **議事録ファイル**: `/議事録_出力/minutes - 2025-01-08 - 会議録.md` に保存

#### フォルダ構造
```
Google Drive
├── 指定フォルダ/
│   ├── 会議録1.m4a ← 新規ファイル（処理待ち）
│   ├── 会議録2.m4a ← 新規ファイル（処理待ち）
│   └── processed/
│       ├── 会議録_古い1.m4a ← 処理済み
│       └── 会議録_古い2.m4a ← 処理済み
└── 議事録_出力/
    ├── minutes - 2025-01-01 - 会議録_古い1.md
    ├── minutes - 2025-01-02 - 会議録_古い2.md
    └── minutes - 2025-01-08 - 会議録1.md ← 新規生成
```

---

### 6. 会議名の抽出ロジック

**会議名の決定優先順位**:
1. **音声内で明示的に言及された会議名**（例: 「プロジェクトキックオフミーティング」）
2. **元のM4Aファイル名**（拡張子を除く）
3. **議題から推測**（例: 「進捗報告会議」）
4. **デフォルト**: 「定例会議」

**実装**: Step2の議題抽出時に会議名も抽出し、JSONに含める

---

### 7. エラーハンドリング要件

#### エラーケース1: Deepgram API失敗
- **原因**: API認証エラー、ネットワークエラー、音声フォーマット不正
- **対応**:
  - エラーログを記録
  - 元のM4Aファイルは移動せず、`/エラー/` フォルダに移動
  - 管理者に通知（Discord等）

#### エラーケース2: AI処理失敗
- **原因**: トークン数超過、API障害、不適切な入力
- **対応**:
  - エラー箇所をログに記録
  - 部分的に生成された議事録を `/議事録_出力/[ERROR]minutes - {日付} - {会議名}.md` として保存
  - 管理者に通知

#### エラーケース3: Google Drive保存失敗
- **原因**: 権限エラー、ストレージ容量不足
- **対応**:
  - 生成された議事録をn8n内部ストレージに一時保存
  - リトライ処理（最大3回）
  - 失敗時は管理者に通知

---

### 8. パフォーマンス要件

#### 処理時間目標
- **1時間の会議**: 5分以内に議事録生成完了
- **内訳**:
  - 文字起こし: 1-2分
  - Step1-3: 1-2分
  - Step4-5: 1-2分
  - 保存・移動: 10秒

#### 同時処理
- **複数ファイル**: 1つずつ順次処理（並列処理は行わない）
- **理由**: API レート制限を回避

---

### 9. セキュリティ・プライバシー要件

#### データ保護
- **音声ファイル**: Google Drive上で保管、n8n内部には一時的にのみ保存
- **文字起こしデータ**: Deepgram APIに送信（処理後即座に削除、データ保持なし）
- **議事録**: Google Drive上に永続保存

#### アクセス制御
- **Google Drive認証**: OAuth2でn8nアプリを認証
- **API Key**: Railway環境変数で管理、コード内にハードコード禁止

---

### 10. 監視・ログ要件

#### ログ記録項目
- **処理開始**: ファイル名、ファイルサイズ、処理開始時刻
- **各ステップ完了**: ステップ名、処理時間、出力データサイズ
- **処理完了**: 議事録ファイル名、保存先、合計処理時間
- **エラー発生**: エラー種別、エラーメッセージ、スタックトレース

#### 通知要件（オプション）
- **処理完了通知**: Discordで通知
- **エラー通知**: 即座にDiscord/メールで管理者に通知
